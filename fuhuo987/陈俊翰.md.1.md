[TOC]

# 前言
这里是陈俊翰学习前端知识的相关笔记
我尽量保持一天一更
因为之前有看过视频所以前面会比较快
写笔记就当复习一遍了
笔记纯手打，错字致歉
* **
* **
# HTML
* ## HTML是一种标记语言  

标签有两种形式，分别为单标签和双标签
双标签如
 ```c
 <div></div>
 <h1></h1>
```
单标签如
```c
<img>
```
* **
* ## 标题标签 

标题标签是双标签
由大到小从h1到h6
<h1>1</h1>
<h2>2</h2>
<h3>3</h3>
<h4>4</h4>
<h5>5</h5>
<h6>6</h6>

标题标签自带加粗
标签的合理运用可以提高SEO
* **
* ## 图片标签 

图片标签是一种单标签，用```<img>```表示，一般打出来长这样```<img src="" alt="" title="" width="" height="">```。其中```src```属性表示路径，需要在这里输入图片的地址，```alt```属性表示图片无法显示时显示的替代文本，```height```和```width```是图片的高和宽，不过一般只输入一个，不然会导致图片变形，title属性表示鼠标悬停在图片上时显示的文字提示。

这里附上我实际写下来的代码作为示例
```c
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
```
因为图片和html文件在一个文件夹里所以直接写了名字。

这里又可以引出图片路径的三种形式，分别是：**<u>绝对路径</u>,<u>相对路径</u>,<u>网络路径</u>**

绝对路径是电脑盘符存储和访问的具体地址，就类似于```D:\wenjian\1234.png```

相对路径是指两者相对关系，如果两者在同一路径下可以直接访问
**1. 子级关系：```/```**
**1. 父级关系：```../```**
**1. 同级关系：```./```（可以省略）**

网络路径就需要写出具体的网络地址
* **
* ## 超文本链接

超文本链接用```<a></a>```表示，他可以是一个字一个词也可以是一个图像，可以通过点击这些内容来跳转到新的文档或者当前文档的某个部分，需要在其```href=“”```中填入跳转网页的地址。

链接将以<font color=Blue><u>蓝色带有下划线</u></font>的字体显示，访问过的链接显示为<font color=Purple><u>紫色带有下划线</u></font>,样式后期可以通过css修改。

比如，我想实现通过点击图片进入游戏的效果，我就可以通过```<a><img></a>```来做到，就像这样：
```
<a href="https://shinycolors.enza.fun/" target="_blank">
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
</a>
```
这里的```target```属性表示新的链接怎么打开，方便控制链接的行为
```_blank``` 链接在新窗口打开
```_parent``` 链接在父窗口打开
```_self``` 默认值，链接在当前窗口打开
```_top``` 在顶层窗口打开
* **
* ## 列表标签

列表标签分为有序列表和无序列表
有序列表通过```<ol><li></li></ol>```来实现
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
列表可以嵌套，可以在一个列表里嵌套另一个列表

```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>

与有序列表相似，无序列表通过```<ul><li></li></ul>```进行表示

```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>
```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>

无序列表常用于做导航效果
* **
* ## 块元素和行内元素

HTML5中元素分类更加细致，但这里还是按照块元素和行内元素来进行学习
| 块级元素 | 内联元素 |
|-----------|------------|
| 块元素会在页面中占据一行（自上而下垂直排列） | 行内元素只会占据自身大小 |
| 块元素可以设置```width```,```height```属性 | 设置这两个属性无效 |
| 一般块元素可以包含其他块元素 | 一般行内元素包含行内元素不包含块级元素|

常见的块级元素有
```div、form、h1~h6、p、table、ul```等等等等

常见的行内元素有
```a、b、em、span、strong```等等等等

还有一些行内块级元素（不换行但是能够识别宽高）
```button、img、input```等等等等
  
  页面布局时需要考虑各个元素的特点
* **
* ## html文件的一般格式

现在才想起来这个还没说。。。
在Visual Studio Code里新建一个html文件，输入 **!+回车键**时就会自动打出基本框架，大概长这样
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
</html>
```
```body```部分是文档的主体，也是用户可以直接看到的内容，```head```里面描述了文档的各种信息，也可以在head里```link```css文件（外部样式）或者写```<style></style>```（内部样式），这些放到下面css的笔记中。
* **
* **
# CSS
* ## 简介

CSS(Cascading Style Sheets)层叠样式表，又叫级联样式表，简称样式表，CSS文件的后缀名为```.css```。

css的目的是让网页更加美观一致

CSS的规则由两个主要部分构成：**选择器，一条或多条声明**
如
```
div{
background-color: blue;
width: 200px;
}
```
每条声明由属性和值构成，属性和值通过冒号分开。
* **
* ## CSS的引入方式

CSS有三种引入方式，分别为：**内联样式、内部样式、外部样式**

**内联样式（行内样式）**
通过在元素后面加上```style```属性来引入css。
```
<img src="283.png" alt="" id="bz" style="user-select: none;">
```
这里就通过内联样式引入了css，将```user-select```属性的值改为了```none```，使图片不可被用户选中。

内联样式不利于维护，尽量少用

**内部样式**
当单个文档需要特殊的样式时就可以使用```<style></style>```标签在文档头部定义内部样式表

**外部样式**
当样式需要用到多个页面时，外部样式表就是一个好选择，可以在外部建立一个css文件，然后再文档头部通过```<link>```标签来进行引入
```
<link rel="stylesheet" href="./css/style.css">

<link rel="stylesheet" href="./css/color.css">
```
需要注意的是优先级的问题，这个放到后面的笔记中进行讨论。
* **
* ## 选择器

在这一部分中讨论css语法规则的一个主要部分：**选择器**

**全局选择器**
可以和任何元素匹配，优先级最低，一般做样式初始化
```
*{
    margin: 0;
}
```
<br>

**元素选择器**
选择文档中的元素，如``` p、div、img ```等等等等，可以描述这些元素的共性

```
table {
    margin-right: auto;
    margin-left: auto;
    border-collapse: collapse;
    table-layout:auto;
}
```
<br>

**类选择器**
相当灵活的选择器，首先先要通过```class```属性定义类，然后通过```.类名```来选择这一个类。注意类名不能以数字开头，同一个标签可以有多个类，通过空格隔开
```
.xz1{
    box-shadow:5px 8px 20px black ;
}
```
这个就是通过类选择器来给元素添加阴影的例子

**ID选择器**
与类选择器类似，需要先给元素定义一个```id```然后通过```#id名```进行选择，注意id尽量不要重复，同样也不能以数字开头

**合并选择器**
有些时候我们想同时选择多个元素，就可以用合并选择器的语法来减少重复代码，选择器之间用逗号隔开
```
table,th{
    border-collapse: collapse;
    border:2px solid black;
}
```
<br>

**选择器的优先级**
css中权重用数字衡量
元素选择器权重：1
类选择器权重：10
id选择器权重：100
内联样式：1000
如果是相同的样式，高权重的会覆盖低权重。

**关系选择器**
关系选择器分为**后代选择器、子代选择器、相邻兄弟选择器、通用兄弟选择器**

1. 后代选择器
选择所有被A包含的B元素用空格隔开
语法为```A B｛｝```
```
#background .jianjie {
    background: rgba(255, 255, 255, 0.5);
    width: 800px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 50px;
}
```
2. 子代选择器
选择E元素的直接子元素F，对更深一层的元素不起作用，用>表示
语法为```E>F{}```

3. 相邻兄弟选择器
选择<u>**紧跟在E元素后**</u>的F元素，用+表示，语法为```E+F{}```

4. 通用兄弟选择器
选择**E元素之后的所有兄弟F元素**，用~表示，语法为```E~F{}```
* **
* ## 盒子模型

所有HTML元素都可以看作盒子，在css中“box model”这一术语是布局和设计时使用

css盒模型本质上是一个盒子，封装周围的HTML元素，它包括：
**外边距（margin）、边框（border）、内边距（padding）、实际内容（content）** 由外到内层层封装

1. margin外边距-清除边框外的区域，外边距是透明的
2. border边框-围绕在内边距和内容外的边框
3. padding内边距-清除内容周边区域，内边距是透明的
4. content实际内容-盒子内容，显示文字和图像

理解盒子模型可以帮助更好的布局网页
* **
* ## 一些常用属性

**字体属性** 
css字体属性定义字体、颜色、大小、加粗、文字样式
```                                                                                                                                                     
#background .box1 #biaoyucn {
    display: block;
    font-size: 50px;
    font-style: italic;
    font-family: "KaiTi";
    text-align: center;
    margin-top: 15px;
    margin-bottom: 0px;
}
```
<br>

**背景属性**
| 属性 | 描述 |
|-------|-------|
| ```background-color``` | 设置背景颜色|
|```background-image```|设置背景图片|
|```background-position```|设置背景图片显示位置|
|```background-repeat```|设置背景图片如何填充|
|```background-size```|设置背景图片大小|
<br>

**文本属性**
| 属性 | 描述 | 值|
|-------|-------|-----|
|```text-align``` | 指定元素文本的水平对齐方式|**left**:默认，文本居左排列；<br>**right**：文本排列到右边；<br>**center**：文本排列到中间|
|```text-decoration```|规定添加到文本的修饰|**underline**：下划线；<br>**overline**：上划线；<br>**line-through**：删除线|
|```text-transform```|控制文本大小写|**captialize**：每个字母开头大写；<br>**uppercase**：全部字母大写；<br>**lowercase**：全部字母小写|
|```text-indent```|规定文本块中首行字母的缩进|/|
<br>

**表格属性**
| 属性 | 描述 |
|-------|-------|
|``` border``` | 设置表格边框|
|```border-collapse```|设置表格边框是否被折叠成一个单一的边框或隔开|
|```width/height```|设置表格宽度/高度|
|```text-align```|设置表格中文本对齐属性|
|```color/background-color```|设置颜色/背景颜色|
<br>

* **
* ## 浮动

```float```属性定义元素在哪个方向浮动，任何元素都可以浮动

浮动只有左右浮动，没有上下浮动
浮动后的元素脱离了文档流，相当于ps里图层格外上加了一个图层，所以会出现折叠现象

当所有元素浮动的时候，会变成水平摆放，向左或向右，当容器不足时会在下一行摆放
* **
* ## 清除浮动
浮动的元素由于脱离了文档流，会导致其父元素高度塌陷，如果不想发生这种情况，就需要清除浮动带来的副作用

一般会用到四种方法

1. 父元素设置高度
给父元素设置```height```属性，将父元素撑开即可
2. 将受影响的元素增加```clear```属性
3. 如果父级塌陷，并且同级元素也受到了影响，可以在父级元素的样式里增加```overflow:hidden```，并在子级的样式里加```clear```属性
4. 通过伪元素的方法解决
在父标签添加伪类```after```，设置空的内容，并且使用```clear:both```注意父布局不设置高度
* **
* ## 定位

```position```属性指定了元素的定位类型
|值|描述|
|--|--|
|```relative```|相对定位|
|```absolute```|绝对定位|
|```fixed```|固定定位|
<br>

在设置定位之后可以使用```left、top、right、bottom```进行调整位置
**相对定位**
对象仍然处于常规的文档流中，但可以通过上面四个属性调整位置

**绝对定位**
对象脱离了文档流，此时偏移属性参照的是距离自身最近的定位祖先元素，如果没有定位的祖先元素，将追溯到```body```元素，每个绝对定位都像新开了一个图层，会出现覆盖情况，可以用```z-index```来调整

**固定定位**
与绝对定位相似，但偏移定位是以窗口为参考，用户滚动窗口时位置不变，具体应用就像广告栏和那种糊脸的广告

用好定位可以使界面更加美观，同时使模块发挥作用
* **
* ## 动画
动画可以使元素从一种样式逐渐变化为另一种样式

可以使用 **@keyframes** 来创建动画
```
@keyframes name{
    from|0%{
        css样式
    }
    percent{
        css样式
    }
    to|100%{
        css样式
    }
}
```
```name```：动画名称
```percent```：百分比值，可以添加多个

**animation执行动画**
```animation: name duration timing-function delay iteration-count direction;```
|值|描述|
|---|---|
|```name```|动画名称|
|```duration```|动画持续时间|
|```timing-function```|设置动画的速率|
|```delay```|设置动画的开始时间|
|```iteration-count```|动画循环次数，infinite为无限次循环|
|```direction```|播放方向|
|```animation-play-state```|控制动画的播放状态：running表示播放，paused表示暂停|
<br>

|timing-function的值|描述|
|----|----|
|```ease```|默认，逐渐变慢|
|```linear```|匀速|
|```ease-in```|加速|
|```ease-out```|减速|
|```ease-in-out```|先加速后减速|
<br>

|direction的值|描述|
|----|----|
|```normal```|默认，向前播放|
|```alternate```|偶数次向前播放，奇数次反向播放|
* **
* ## css嵌套

css嵌套使样式表更加容易阅读、模块化，同时也更容易维护，因为不需要重复选择器，文件同样可以被压缩

1.**子选择器**
可以使用css嵌套来创建一个父级的子选择器，这可以用来选择特定父元素的子元素，使用```&```来实现

有几个特定环境可以使得`` `&``` 嵌套选择器变得很必要或者有用：

-   在连接选择器时，如组合选择器或伪类
-   为了向后兼容。
-   作为一个辅助阅读的标志。当你看到 ```&``` 时，你就知道这里用到 CSS 嵌套了。
```
/* 不使用嵌套选择器 */
parent {
  /* 父样式 */
  child {
    /* 父级的子样式 */
  }
}

/* 使用嵌套选择器 */
parent {
  /* 父样式 */
  & child {
    /* 父级的子样式 */
  }
}

/* 浏览器均会把以上两个样式表解析为 */
parent {
  /* 父样式 */
}
parent child {
  /* 父级的子样式 */
}
```
2.**关系选择器**
css关系选择器也可在使用或不使用```&```嵌套选择器的情况下使用

```
h2 {
  color: tomato;
  + p {
    color: white;
    background-color: black;
  }
}
```
如果使用```&```嵌套选择器，只需在```+```前面加个```&```即可

3.**组合选择器**
与关系选择器不同，在使用组合选择器时，必须使用```&```嵌套选择器，这是因为浏览器会自动在不使用```&```嵌套选择器的选择器之间添加空格
```
.a {
  /* 带有 class="a" 元素的样式 */
  .b {
    /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
  }
  &.b {
    /* 带有 class="a b" 元素的样式 */
  }
}

/* 浏览器会将其分析为 */
.a {
  /* 带有 class="a" 元素的样式 */
}
.a .b {
  /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
}
.a.b {
  /* 带有 class="a b" 元素的样式 */
}
```

4.**后附嵌套选择器**
```&```嵌套选择器可以放到一个选择器的后方，这样可以反转上下文
```
.foo {
  /* .foo 的样式 */
  .bar & {
    /* .bar .foo 的样式 */
  }
}
```
<br>

如果一个嵌套 CSS 规则无效，那么所有其包含的样式都将被忽略。这不影响其父级及其后面的规则。

使用css嵌套可以将包含任何样式的at规则嵌入到另一个规则中。嵌套在at规则从距离它们最近的祖先规则中获得选择器定义

可以被嵌套的at规则有：

1. ```@media```
2. ```@support```
3. ```@layer```
4. ```@scope```
5. ```@container```

以```@media```为例，使用at规则嵌套的css为：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
```
此时浏览器解析嵌套块是这样的：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    & {
      grid-auto-flow: column;
    }
  }
}
```
如果不使用at嵌套，那么它的等价表示是：
```
.foo {
  display: grid;
}

@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
```

at规则也可以嵌套其他at规则，如：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
    @media (min-width: 1024px) {
      max-inline-size: 1024px;
    }
  }
}
```
如果不使用嵌套的方法，它的等价表示是这样：
```
.foo {
  display: grid;
}
@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
@media (orientation: landscape) and (min-width: 1024px) {
  .foo {
    max-inline-size: 1024px;
  }
}
```
<br>

**嵌套的优先级**
```&```嵌套选择器的优先级由它所关联的选择器列表中优先级最高的选择器决定
```
<b class="foo">
  <c>蓝色文字</c>
</b>
```
```
#a, b {
  & c {
    color: blue;
  }
}

.foo c {
  color: red;
}
```
在这个示例中，ID 选择器（```#a```）的优先级是 ```1-0-0```，而类型选择器（```b```）的优先级是 ```0-0-1```。```&``` 嵌套选择器有 ```1-0-0``` 的优先级，尽管 ID 选择器 ```#a``` 从未使用。

类选择器 ```.foo``` 的优先级是 ```0-1-0```。经过计算得出，```& c``` 的总优先级是 ```1-0-1```，而 ```.foo c``` 的优先级是 ```0-1-1```，意味着 ```color: blue;``` 是最后赢家

在使用嵌套选择器的时候要注意优先级问题
*  **
* ## At规则
由于上文提到了at规则，于是在这里再做一下笔记

at规则是一个css语句，用来指示css如何运行，以```@```开头后跟一个标识符，并包括直到下一个分号的所有内容，或下一个 CSS 块，以先到者为准

下面是一些不同的at规则：
| 名称 |描述 |
|--|--|
|```@charset``` | 定义样式表使用的字符集|
| ```@import``` |告诉 CSS 引擎引入一个外部样式表 |
| ```@namespace``` | 告诉 CSS 引擎必须考虑 XML 命名空间 |
<br>

嵌套 at 规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：
| 名称 |描述  |
|--|--|
| ```@media``` |如果满足媒介查询的条件则条件规则组里的规则生效  |
|```@supports```  | 如果满足给定条件则条件规则组里的规则生效 |
|```@document```  |如果文档样式表满足给定条件则条件规则组里的规则生效  |
|``` @page``` | 描述打印文档时布局的变化 |
| ```@font-face``` | 描述将下载的外部的字体 |
| ```@keyframes``` | 描述 CSS 动画的中间步骤 |
| ```@layer```| 声明一个级联层，并在有多个级联层时定义优先顺序。|
<br>

**条件规则组**
每条at规则都有不同的语法，但一些at规则可以被归为一个特殊的分类：条件规则组。它们都使用相同的语法，它们都表达：它们所指的条件 (类型不同) 总等效于 **true** 或者 **false**，如果为 **true** 那么它们之中的语句生效。如```@media```、```@supports```、```@document```
* **
* ## 媒体查询

媒体查询可以使页面在不同终端下显示不同效果，会根据设备的大小自动识别加载不同的样式

**设置```meta```标签**
在```<head>```里加入这个```meta```标签能将使用设备的宽度作为初始宽度并禁止初始缩放
```
<meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1,user-scalable=no">
```
1. ```width=device-width```宽度等于当前设备的宽度
2. ```initial-scale=1.0```初始的缩放比例（默认1.0）
3. ```maximum-scale=1```允许用户缩放到的最大比例（默认1.0）
4. ```user-scalable=no```用户是否可以手动缩放 (默认是no）

```
@media screen and(max-width:768px)
/*设备小于768px加载样式 */
    body{}
}
@media screen and(max-width: 992px)and(min-width:768px){
/*设备小于768px但小于992px加载样式 */
    body{}
}
@media screen and(min-width:992px){
/*设备大于992px加载样式*/
    body{}
}
```
* ## flex布局
Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。

之所以称flexbox是一种一维的布局，是因为它不像grid布局一样可以同时处理行和列，它一次只能处理一行或者一列上的元素布局。

flexbox有两根轴线：**主轴**和**交叉轴**，主轴由```flex-direction```定义，可以取以下四个值：

1. ```row```（默认）
2. ```row-reverse```
3. ```column```
4. ```column-reverse```

有```-reverse```的相比没有的起始线和终止线相反![输入图片说明](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics5.svg)

选择```row```或```row-reverse```主轴按行的方向延伸，反之主轴将上下延伸

交叉轴垂直于主轴

flex容器有多种属性：
|属性  |值  |描述|
|--|--|----|
|```flex-direction```|**row（默认）<br> row-reverse column<br> column-reverse**  | 改变flex元素的排列方向    |
|```flex-wrap```| **wrap <br>nowrap（默认）** | 项目太大无法显示在一行中时换行显示    |
|```align-items```|**stretch**(默认，元素拉伸到最高元素的高度)<br> **flex-start**(顶部对齐) <br>**flex-end**(底部对齐) <br>**center**(居中对齐)|使元素在交叉轴方向对齐|
|```justify-content```|**flex-start**(默认，元素从起始线排列)<br> **flex-end**(从终止线开始排列) <br>**center**(在中间排列)<br> **space-around**(元素之间间隔相等)<br> **space-between**(元素的左右空间相等)|使元素在主轴方向上对齐|
|```align-content```|**flex-start**(与交叉轴的起点对齐)<br>**flex-end**(与交叉轴的终点对齐) **center**(与交叉轴的中点对齐) <br> **space-between**(与交叉轴两端对齐，轴线之间的间隔平均分布) <br>**space-around**(每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍) <br>**stretch**(默认值，轴线占满整个交叉轴)|定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用|
<br>

```flex-direction```和```flex-wrap```这两种属性可以合并写为```flex-flow: 值1 值2```,第一个指定的值为 ```flex-direction``` ，第二个指定的值为 ```flex-wrap```

flex元素也有多种属性：

|属性|描述  |
|--|--|
|```flex-grow```  | 定义了在有可用空间时的放大比例 |
| ```flex-shrink``` | 定义了在空间不足时的缩小比例 |
|```lex-basis```  | 指定了项目在分配空间前的初始大小 |
<br>

这几个flex属性的作用其实就是改变了flex容器的可用空间的行为（在把flex项目用到多行的时候，应该把每一行都看作一个新的flex容器），这三个属性可以合并成```flex: 值1 值2 值3```，三个值分别对应```flex-grow```，```flex-shrink```，```flex-basis```

大多数情况下用预定义的简写形式
| 简写 | 相当于 |
|--|--|
|```flex: auto```  | ```flex: 1 1 auto ```|
|```flex: initial```  | ```flex: 0 1 auto ```|
|```flex: none```  | ```flex: 0 0 auto``` |
| ```flex: 1``` | ```flex: 1 1 0``` |
| ```flex: 2``` | ```flex: 2 1 0``` |
|```flex: num```|```flex: num 1 0```


* **
* ## grid布局

grid布局即网格布局，引入了二维网格布局系统

网格是一组相交的水平线和垂直线，它定义了网格的行和列，可以把网格元素放在这些行列相关的位置上

网格布局的特点有：

1. **固定的位置和弹性的轨道大小**：既可以使用固定的轨道尺寸创建网格，也可以使用百分比或者```fr```来创建有弹性尺寸的网格
2. **网格项摆放**：可以使用行号、行名或者标定一个网格区域来精确定位元素，同时还使用一种算法来控制未给出明确网格位置的元素
3. **创建额外的轨道来包含内容**：可以通过网格布局定义显式网格。网格布局规范非常灵活，可以在需要时添加额外的行和列。包括添加“一个容器能容纳的尽可能多的列”等特性
4. **对齐控制**：网格包含对齐特性，因此我们可以控制项目放入网格区域后的对齐方式，以及整个网格的对齐方式
5. **控制重叠内容**：多个项目可以放置在网格单元格中，或者区域可以部分地彼此重叠。然后可以使用 ```z-index``` 属性来控制重叠区域显示的优先级

通过在元素上声明```display: 	grid```来创建一个网格容器，里面的所有直系子元素都将成为网格项目

使用 ```grid-template-rows```和 ```grid-template-columns```属性定义网格上的行和列。这些属性定义了网格轨道。_网格轨道_（grid track）是网格上任意两条相邻线之间的空间。

轨道可以使用任何长度单位进行定义，也可以使用一个新单位```fr```来定义轨道大小，也可以混合使用单位如```grid-template-columns: 500px 1fr 2fr;```就是在可用空间扣除了500px宽度后再一分为三按比例分配

包含多个轨道的大型网格可使用 ```repeat()``` 标记来重复部分或整个轨道列表，如```grid-template-columns: 1fr 1fr 1fr;```就可以写成```grid-template-columns: repeat(3,1fr);```。同时```repeat()```也可以重复轨道列表中的一部分。如果是```repeat(5,1fr,2fr)```就意味着网格有十个轨道，为1个```1fr```后面跟着一个```5fr```，这样重复五次

如果希望行或列的大小永远不会小于一个值时，可以使用```minmax()```函数，如 ``` grid-auto-rows: minmax(100px, auto);```就意味着行高度最小为100px，最大为auto，使用 auto 表示大小将取决于内容的大小，并将拉伸以在该行中为单元格中最高的项目留出空间。

在定义网格时，定义的是网格轨道而非网格线，一个三行两列的网格中有四条纵向的网格线，网格线的编号顺序取决于文章的书写格式，网格线也可以被命名

使用 ```grid-column-start```、```grid-column-end```、```grid-row-start``` 和 ```grid-row-end``` 属性可以将项目放到自己想要的位置，也可以跨轨道放置，注意目标是网格线而不是网格轨道。这个有简写，如：```grid-column```和```grid-row```，值为 ```值1/值2```，值1为起始网格线，值2为终止网格线，也可以更进一步，合并为```grid-area```属性，同样用```/```分开，值的顺序为```grid-row-start```/```grid-column-start```/```grid-row-end```/```grid-column-end```

项目可以按行或者列跨越一个或多个单元格，形成了一个*网格区域*，网格区域必须是矩形的

网格单元格之间的横向间距或纵向间距可以使用```column-gap```和```row-gap```属性（简写为```gap```）

网格间距使用的任何空间都会在分配给灵活长度的 ```fr``` 轨道之前计算在内，而且网格间距的大小与常规网格轨道相同，但不能在间距中放置任何东西。就基于行的定位而言，网格间距就像一条粗线。

网格也可以嵌套，将一个网格项作为一个网格容器，如果不使用子网格的嵌套，那么嵌套网格和父网格没有任何关系，不会继承父网格的属性

*子网格*(subgrid)能让在创建嵌套网格的同时使用父网格的轨道定义，如将 ```grid-template-columns: repeat(3,1fr)```的轨道定义更改为 ```grid-template-columns: subgrid```。嵌套网格就会沿用父网格轨道来布局项目。

网格项可以占据同一单元格，可以使用```z-index```属性改变堆叠顺序（这里好像和绝对定位挺像的），就是当一个单元格被两个网格区域覆盖时就可以改变```z-index```的值决定谁在上面

在抉择布局方式时，应该思考是**只需要按行或者列布局**还是要**同时按行和列布局**，以此决定使用弹性盒子布局还是网格布局

css的网格布局是一种很好用的工具，应该大胆尝试与其他布局方法混用，获得想要的页面效果
* **
 * # JavaScript
 *  ## 简介
 
JavaScript是一种轻量级的脚本语言，所谓脚本语言，就是指它不具备开发操作系统的能力，只用来编写其他大型应用程序的脚本

JavaScript是一种嵌入式语言，它本身提供的核心语法不算很多

*  **
* ## JavaScript的语句和标识符
JavaScript程序单位是行，一般情况下一行就是一个语句，语句以分号结尾，一个分号表示一个语句结束

标识符指的是用来识别各种值的合法名称，最常见的就是各种变量名称，注意不能以数字开头
* **
* ## JavaScript引入方式
和css类似，JavaScript也有三种常用引入方式：

1. 嵌入到html文件中
用```<script></script>```标签包含js代码
2. 引入本地js文件
语法如```<script src="./js/1.js"></script>```在```src```里写入js文件的地址即可
3. 引入网络来源文件
即在```<script src=""></script>```的```src```里填入网络来源的js文件地址


* **
* ## 常用运算符
**typeof运算符**
JavaScript有三种方法可以确定一个值是什么类型，最先接触到的是```typeof```

1. 数值返回number
2. 字符串返回string
3. 布尔值返回boolean
4. 对象返回object
5. 没有数值返回undefined
<br>

**算数运算符**
| 运算符 | 描述 |
|--|--|
| ```+``` | 加 |
|``` -``` | 减 |
|``` * ```| 乘 |
| ```/``` | 除 |
|``` % ```| 取余 |
| ```p++``` | 先运算再自增 |
|``` ++p ```| 先自增再运算 |
<br>

**赋值运算符**
| 运算符 | 描述 |
|--|--|
|``` = ```| 赋值运算符 |
|``` +=``` | x+=y等同于x=x+y |
| ```-= ```| x-=y等同于x=x-y |
| ```/= ```| x/=y等同于x=x/y|
|``` *=``` | x*=y等同于x=x*y |
| ```%=``` | x%=y等同于x=x%y |
<br>

**比较运算符**
| 运算符 | 描述 |
|--|--|
|```<``` | 小于 |
| ```>``` | 大于 |
|``` <=``` | 小于等于 |
| ```>=``` | 大于等于 |
|``` ==``` | 相等 |
| ```===``` | 严格相等 |
| ```!= ```| 不等于 |
| ```!==``` | 严格不等于 |
<br>

**布尔运算符**
| 运算符 | 描述 |
|--|--|
|``` ! ```| 取反 |
| ```&&``` | 且 |
| ```||``` | 或 |
 * **
 *  ##条件语句
 
 **if语句**
 if语句先判断一个表达式的布尔值，然后根据布尔值的真伪执行不同的语句，语法如下：
 ```if(flag){要执行的语句}```
 
 **if...else语句**
 if代码块后面可以跟一个else代码块，表示不满足条件时要执行的代码，语法如下：
  ```
  if(flag){
        要执行的语句
    }else{
        要执行的语句
    } 
```
如果在不同条件下要执行不同的代码，可以使用if...else if...else语句，else if可以任意多，语法如下：
```
  if(flag){
        要执行的语句
    }else if(flag2){
        要执行的语句
    }else{
        要执行的语句
    } 
```
<br>

**switch语句**
在有多种选择的情况下也可以考虑使用switch语句，注意的是每一个```case```最后都要有一个```break```，否则会继续执行下一个case代码块，语法如下：
```
   switch(变量){
       case 值1:
           代码块
           break;
       case 值2:
           代码块
           break;
       case 值3:
           代码块
           break;
       default:
           代码块
   }
```
* **
* ## 循环语句
循环语句就是重复执行某个操作

**for语句**
for语句就是循环命令，可以指定循环的起点、终点和终止条件，语法如下：
```
for(初始化表达式;条件;循环因子){
    要循环的语句
    }
```
其中初始化表达式只在循环开始时执行一次，条件每轮循环开始时都要执行一遍，只有布尔值为真时才执行此次循环，循环因子是每轮循环的最后一次操作，通常用来递增循环变量

** while语句**
while语句包含一个循环条件和代码块，只要条件为真就执行代码块，直到条件为假时或遇到```break```跳出循环，语法如下：
```
while(条件){要循环的语句}
```
需要注意的是在语句内应该有改变与条件有关变量的语句或```break```语句，防止出现死循环

所有for循环都可以写成while循环，反之亦然

循环语句可以嵌套，通过循环语句嵌套可以实现想要实现的效果

**break语句和continue语句**
```break```和```continue```都可以让代码不按原有的顺序进行

```break```语句用于跳出代码块或者循环，遇到```break```意味着循环的结束

```continue```语句意味着立刻终止本轮循环，返回循环体的头部，开始下一轮循环
 *   **
 * # 图解HTTP笔记
 * ## 第一章 了解Web及网络基础

Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端灯一系列运作流程，可以说，Web是建立在HTTP协议上通信的

CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李博士提出了一种能让远隔两地的研究者们共享知识的设想

现在已经提出了三项WWW（World Wide Web，万维网）构建技术，分别是：
1. **HTML**（HyperText Markup Language，超文本标记语言），它的页面文本标记语言为SGML（Standard Generalized Markup Language，标准通用标记语言）
2. **HTTP**，作为文档传递协议
3. **URL**（Uniform Resource Locator，统一资源定位符）
<br>

CERN成功研发了世界上第一台Web服务器和Web浏览器

HTTP于1990年问世，但没有作为正式的标准被建立，被称为HTTP/0.9。HTTP正式作为标准被公布是在1996年五月，被命名为HTTP/1.0，该协议标准至今仍被广泛用于服务器端。1997年一月公布的HTTP/1.1是目前主流的HTTP协议版本，当初的标准是RFC0，之后的修订版RFC2616就是当前的最新版。

当年HTTP协议主要是为了解决文本传输的难题，但现在已经超出了Web框架的局限

通常使用的网络是在**TCP/IP**协议族的基础上运作的，HTTP是它内部的一个子集

计算机与网络设备要互相通信就必须基于相同的方法，我们把这个规则称为**协议**，而TCP/IP就是互联网相关各类协议族的总称（也有说法是TCP协议和IP协议，或者是IP协议通信过程中使用到的协议族的统称）

TCP/IP协议很重要的一点就是分层，其按层次分分为**应用层、传输层、网络层、数据链路层**，分层使各个层次内部的设计可以自由改动，简化设计。各层的作用如下：
|层|作用  |
|--|--|
| **应用层** |决定了向用户提供应用服务时通信的活动，HTTP协议也属于该层  |
| **传输层** | 对上层应用层提供处于网络连接中的两台计算机之间的数据储传输，有TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol， 用户数据报协议） |
| **网络层（网络互连层）** |处理网络上流动的数据包，规定通过怎样的路径（传输路线）到达对方计算机传送数据包  |
| **链路层** |处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围里  |
<br>

在利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层向下走，接收端从链路层向上走

发送端在层与层之间传输数据时，每经过一层必定会打上该层所属的首部信息，而接收端则在层与层传输时消去对应的首部
|XX层->XX层| 首部|
|--|--|
| **应用层->传输层** | TCP首部 |
| **传输层->网络层** | IP数据包（IP首部） |
|  **网络层->链路层** | 网络架构（以太网首部） |
这种把数据信息像快递一样层层包装起来的做法叫做封装

TCP/IP协议中与HTTP协议密不可分的有三个协议：

1. **IP协议**
IP（Internet Protocol）协议负责传输，属于网络层，几乎所有使用网络的系统都会用到这个协议。IP 协议的作用是把各种数据包传送给对方。要保证确实传送到对方那里要满足各种条件，最重要的是IP 地址和 MAC地址（Media Access Control Address）<br><br>IP 地址（可以更改）指明了节点被分配到的地址， MAC 地址（基本上不会更改）是指网卡所属的固定地址。<br><br>IP间的通信依赖MAC地址，因为通信通常是要经过多台计算机和网络设备中转，中转时就要利用下一个设备的MAc地址来搜索，这时会采用ARP协议（Address Resolution Protocol，是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址）<br><br>在到达通信目标前，中转计算机和路由器只能获得很粗略的传输路线，这种机制成为路由（routing），无论哪台计算机、网络设备都无法全面掌握互联网的细节
2. **TCP协议**
TCP协议用于确保可靠性，属于传输层，提供可靠的字节流服务<br><br>字节流服务指的是为了方便传输将大块数据分割成以报文段为单位的数据包进行管理。TCP协议为了更容易传送大数据才将数据分割，而且能够确认数据最终是否送达到对方<br><br>为了准确送达，TCP协议采用了三次握手策略，在用TCP协议将数据包送出去后，TCP一定会向对方确认是否成功送达，握手过程中使用TCP的标志（flag）——**SYN**（synchronize）和**ACK**（acknowledgement）<br><br>首先，发送端会发送带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包表示确认，此时发送端会回传一个带ACK标志的数据包，代表“握手”的结束。如果握手过程突然中断，TCP协议会再以相同的顺序发送数据包。<br><br>（除了上述三次握手， TCP 协议还有其他各种手段来保证通信的可靠性）
3. **DNS协议**
DNS（Domain Name System）协议负责域名解析，属于应用层，提供域名到IP地址间的解析服务<br><br>计算机可以被赋予IP地址、主机名、域名，用户通常使用主机名和域名来访问对方的计算机（因为IP地址是一组纯数字），但是计算机比起处理名称更擅长处理一长串数字，由此，DNS服务诞生了，它提供提供域名查找IP地址，或通过IP地址逆向搜索域名的服务<br><br>发送端想访问一个域名，DNS协议会查找到这个域名对应的IP地址，然后发送端会向这个IP地址发送访问请求

如果要把通信过程中各个协议的作用表述出来，大概就像这样：
发送端想访问一个域名
**DNS协议**会查找到这个域名对应的IP地址。
**HTTP协议**会生成针对目标Web服务器的HTTP请求报文。
**TCP协议**将请求报文分割成多段，按序号分层多个报文段然后将每个报文段可靠地传给对方。
**IP**协议搜索对方的地址，一边中转一边传输。
接收端的**TCP协议**按序号重组报文段。
接收端的**HTTP协议**处理对Web服务器请求的内容。
请求的处理内容同样利用TCP/IP通信协议进行回传

与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。URL正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。

URI 是 Uniform Resource Identifier 的缩写
**Uniform：**规定统一的格式，方便处理多种不同类型的资源，不需要根据上下文环境来识别资源指定的访问方式，加入新的协议方案也更容易
**Resource：**资源的定义是“可标识的任何东西”。资源不仅可以是单一的， 也可以是多数的集合体
**Identifier：**表示可标识的对象。 也称为标识符

URI 就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称，比如采用HTTP协议时，协议方案就是http

URI 用字符串标识某一互联网资源，而 URL表示资源的地点（互联网上所处的位置） 。可见 URL是 URI 的子集

表示指定的URI，可以使用**绝对URI、绝对URL、相对URL**，相对URL指的是从浏览器中基本URI处指定的URL，如 /image/logo.gif

**绝对URI**组成如下：
|名称|描述  |
|--|--|
| **协议方案名** |使用http:或 https:等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）|
|**登录信息**  | （可选），指定用户名和密码作为从服务器端获取资源时必要的登录信息 |
| **服务器地址** | 使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名 |
| **服务器端口号** | （可选）指定服务器连接的网络端口号。若用户省略则自动使用默认端口号 |
| **带层次的文件路径** | 指定服务器上的文件路径来定位特指的资源 |
|**查询字符串**  | （可选）针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数 |
| **片段标识符组成** |（可选）使用片段标识符通常可标记出已获取资源中的子资源  |
<br>

有一些用来制定 HTTP 协议技术标准的文档,它们被称为RFC（Request for Comments, 征求修正意见书）,不遵照 RFC 标准实现就无法进行 HTTP 协议通信

* **
* ##第二章 简单的HTTP协议

应用HTTP协议时，一端担任客户端角色，一端担任服务器端角色，请求访问资源的是客户端，提供资源响应的是服务器端，角色有可能互换，但HTTP协议能明确区分哪个是客户端哪个是服务器端

HTTP协议规定请求从客户端发出，服务器端响应请求并返回

这个是从客户端发出的请求报文的内容：
```
GET/index.htm HTTP/1.1
Host:hackr.jp
```
开头的```GET```表示请求访问服务器的类型，称为方法
字符串```/index.htm```指明了请求访问的资源对象，也叫做请求URI
最后的HTTP/1.1是HTTP的版本号
请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的

收到请求的服务器会将请求内容的处理结果以响应的形式返回
```
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT Content-Length: 362
Content-Type: text/html
<html>
……
```
开头的```HTTP/1.1```表示服务器对应的HTTP版本
```200 OK```表示请求处理结果的状态码和原因短语。
下一行显示了创建响应的日期时间，是首部字段内的一个属性
空一行
后面是资源实体的主体

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码） 、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成

HTTP是无状态协议，意味着它不保存状态，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。这个是为了更快地处理大量事务，确保协议的可伸缩性

但随着发展，有些情况网站需要保存用户的状态，于是引入了Cookie技术，这样就可以管理状态了

由于URI的存在，使HTTP协议能定位互联网上的资源从而进行访问

当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI，如：
```
OPTIONS * HTTP/1.1
```
<br>

方法的作用在于可以指定请求的资源按期望产生某种行为，HTTP/1.1中可使用的方法（method）：
1. **GET：获取资源**
GET用来<u>请求访问已被URI识别的资源</u>。指定的资源经服务器端解析后返回响应内容
2. **POST：传输实体主体**
虽然GET方法也可以传输实体的主体，但一般不用GET方法而是使用POST方法，虽然相似，<u>但POST方法的主要目的斌不是回去响应的主体内容</u>
3. **PUT：传输文件**
PUT方法用来传输文件，要求<u>在请求的报文的主体中包含文件内容，然后保存到请求URI指定的位置</u>。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，一般的Web网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT 方法。
4. **HEAD：获取报文首部**
该方法和GET方法一样，只是<u>不返回报文主体部分</u>，用来确认URI的有效性和资源更新的日期时间等
5. **DELETE：删除文件**
是和PUT相反的方法，按请求URI删除指定的资源。但它也和PUT一样没有验证机制，一般Web网站不使用
6. **OPTIONS：询问支持的方法**
用来查询针对请求URI指定的资源支持的方法
7. **TRACE：追踪路径**
该方法是让Web服务器将之前的请求通信环回给客户端的方法<br><br>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。<br><br>客户端用TRACE方法可以查询发出去的请求是怎么样被加工修改的，确认连接过程中发生的一系列操作<br><br>但是TRACE方法本来就不常用，还容易引发XST（Corss-Site Tracing，跨站追踪）攻击
8. **CONNECT：要求用隧道协议连接代理**
该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输

向请求URI指定的资源发送请求报文时，采用称为方法的命令

除了以上方法，HTTP/1.0还有LINK（建立和资源之间的联系）和UNLINK（断开连接关系）方法，但已被HTTP/1.1废弃

在HTTP的初始版本中，每进行一次HTTP通信都要断开一次TCP连接，每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销

为了解决这个问题，HTTP/1.1和一部分的HTTP/1.0推出了**持久连接**的方法，只要任意一端没有明确提出断开连接就保持TCP连接状态。这种方法减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。在HTTP/1.1中，所有连接默认都是持久连接

持久连接使**管线化**成为可能，<u>不需要等待上一个请求得到响应就可以之间发送下一个请求</u>,速度更快

在上面的笔记中有提到Cookie技术的引入使Web可以进行状态的管理

**Cookie技术**通过在请求和响应报文中写入Cookie信息来控制客户端的状态。如果客户端的请求报文中没有Cookie的相关信息，服务器端发送的响应报文中会有一个叫Set-Cookie的首部字段信息通知客户端保存Cookie。客户端以后的请求中会自动在请求报文中加入Cookie值后发送。服务器端在发现客户端发来的Cookie后回去检查时哪个客户端发来的请求，对比服务器上的记录，得到之前的状态信息

 * **
 * ## 第三章 HTTP报文内的HTTP信息
 
用于HTTP协议交互的信息被称为HTTP报文，请求端的叫**请求报文**，响应端的叫**响应报文**。HTTP报文本身是由多行数据（CR+LF作换行符）数据构成的字符串文本

HTTP报文大致分为报文首部和报文主体，由空行划分，并不一定要有报文主体

请求报文和响应报文首部的结构：
|请求报文| 响应报文 |
|--|--|
|请求行  | 状态行 |
| 请求首部字段 | 响应首部字段 |
| 通用首部字段 | 通用首部字段 |
| 实体首部字段 | 实体首部字段 |
| 其他 | 其他 |
<br>

**请求行**
包含请求的方法，请求URI和HTTP版本
**状态行**
包含表明响应结果的状态码，原因短语和HTTP版本
**首部字段**
一般有四种首部，分别是**通用首部、请求首部、响应首部和实体首部**（可能还有Cookie等）

通过在传输时编码，能有效处理大量访问请求。编码操作需要计算机完成，会消耗更多CPU资源

**报文**是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
**实体**是作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成

HTTP 报文的主体用于传输请求或响应的实体主体，通常报文主体等于实体主体，但当传输中进行编码操作时实体主体内容发生变化，于是产生了差异

HTTP协议中有一种被称为**内容编码**的功能，内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码

常用的内容编码有以下几种：
1. gzip（GNU zip）
2. compress（UNIX 系统的标准压缩）
3. deflate（zlib） 
4. identity（不进行编码）

如果请求段编码实体资源尚未全部传输完成，浏览器无法显示请求页面，所以在传输大容量数据时，通过把数据分割成多块**分割物（chunk）**，能够让浏览器逐步显示页面，这种功能称为**分块传输编码**

每一块分割块都会用十六进制来标记大小，实体主体的最后一块会使用“0（CR+LF）”来标记，使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到解码前的实体主体

HTTP 协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用

多部分对象集合包含的对象如下：
1. **multipart/form-data**
在Web表单文件上传时使用
2. multipart/byteranges
状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type

boundary字符串用来划分多部分对象集合指明的各类实体。在其指定的各个实体的起始行前插入“--”标记，在多部分对象集合对应的字符串的最后插入“--”标记作为结束

如果下载时网络中断，那么就不得不再次从头下载，这个问题想要得到解决需要指定下载的实体范围。指定范围发送的请求叫做**范围请求**

执行范围请求时，会用到首部字段Range来指定资源的byte范围

```Range：bytes=5000-10000```就是指定了5000~10000字节，也可以有```Range：bytes=5000-10000，12000-15000```的双重范围

针对范围请求，响应会返回状态码为206 Partial Content的响应报文。如果是多重范围，那么响应会在首部字段ContentType标明multipart/byteranges后返回响应报文

（如果服务器端没办法响应范围请求，那么就会返回状态码200 OK和完整的实体内容）

**内容协商**机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，包含在请求报文中的某些首部字段会作为判断是否是最合适资源的基准，如：**Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language**

内容协商技术有三种类型：
|类型| 描述 |
|--|--|
| **服务器驱动协商** | 由服务器端进行内容协商，以请求的首部字段进行参考，但对用户来说不一定是最合适的 |
| **客户端驱动协商** | 由客户端进行内容协商，就类似于手动选择浏览器语言。存在需要第二次请求而获得最好表现形式的缺点。第二次请求只有当缓存被使用时才是有效率的 |
| **透明协商** | 服务器驱动和客户端驱动的结合体，两端各自进行内容协商。结合了服务器和客户端的协商能力，能够更好地满足不同用户的需求。通过缓存利用代理驱动协商的信息，减少了服务器的负担，提高了响应速度。提供最适合用户的资源，提升用户体验‌ |

 * **
 * # 代码部分

后面的想法就是做个导航栏还有下面色彩选择的部分希望能选择一个色彩展示人物相关信息
看考核要求最后说不定还能加个问卷？
* ## html文档 
```
<!DOCTYPE html>

<html lang="en">

  

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>fuhuo</title>

<link rel="stylesheet" href="./css/style.css">

<link rel="stylesheet" href="./css/color.css">

<style>

</style>

</head>

  

<body>

<script src="./js/1.js"></script>

<img src="2.png" alt="偶像大师闪耀色彩标题" id="tphoto">

<div class="bjtp"></div>

<div id="topicbox">

</div>

<div id="box0">

<b id="topic">fuhuo的偶像大师闪耀色彩试验性demo</b>

</div>

<div id="background">

<div class="box1">

<img src="283.png" alt="283PRO标志" id="bz" style="user-select: none;">

<h1 id="biaoyucn">闪耀吧，让偶像的一切</h1>

<h1 id="biaoyu">輝かせよう、アイドルのすべて</h1>

</div>

<div class="jieshao">本demo旨在通过实操的方式学习前端相关知识，因为是边学边做，所以程序可能比较混乱，但有稍微整理过。</div>

<div class="jianjie">

<div style="border-left: 10px solid greenyellow ;">

<h1 style="color: aqua;">简介</h1>

</div>

<h2>你说的对，但————</h2>

<a href="https://shinycolors.enza.fun/" target="_blank"><img src="283pro.png" alt="283PRO场景" class="283pro"

width="400px" style="float: right;" title="点击进入283PRO"></a>

<ul>

<li>《偶像大师闪耀色彩》（アイドルマスター

シャイニーカラーズ）是由万代南梦宫NEXUS（前身为BXD）旗下的enza平台开发的一款模拟养成类抽卡社交网页游戏，为偶像大师系列作品之一，于2018年4月24日开始运营。</li>

<p></p>

<li>《偶像大师闪耀色彩》背景设定在东京都的283事务所(283谐音“翅膀”)。玩家将培养和管理偶像，参与各种活动和演出。游戏特色在于其与现实时间同步的季节变化，以及丰富的剧情和角色成长系统。玩家可以在一个充满生活气息的环境中，体验偶像的成长和挑战。游戏的UI设计贴近现实，让玩家仿佛置身于偶像的日常生活之中。通过玩家的选择和互动，偶像们将经历各种故事线，展现不同的成长和变化。《偶像大师闪耀色彩》（アイドルマスター

シャイニーカラーズ）是由万代南梦宫NEXUS（前身为BXD）旗下的enza平台开发的一款模拟养成类抽卡社交网页游戏，为偶像大师系列作品之一，于2018年4月24日开始运营。</li>

</ul>

</div>

<div class="box2">

<div style="border-left: 10px solid rgb(0, 26, 255) ;">

<h3>目前283PRO共有:</h3>

</div>

<h1 style="font-size: 60px ; font-style: italic; padding-left: 260px; position: relative; top: 0%;

left: 50%;

transform: translate(-50%, -75%); user-select: none;" class="ho" id="qhs">28colors

</h1>

</div>

<div><button class="qk" onmouseover="qingkong()">清空选择</button></div>

<div>

<table class="colors">

<tr>

<th colspan="3"><img src="zh/xing.png" alt="" class="zh"></th>

<th colspan="5"><img src="zh/ant.png" alt="" class="zh"></th>

</tr>

<tr >

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mano" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="jiaozi" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mgr" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="kgn" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mmm" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="sky" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="fff" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="krk" onmouseover="xuanzhong()"></div>

</div>

</th>

</tr>

<tr>

<th colspan="5"><img src="zh/fkh.png" alt="" class="zh" style="height: 100px;"></th>

<th colspan="3"><img src="zh/hua.png" alt="" class="zh"></th>

</tr>

<tr>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="kaho" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="cyk" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="juri" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="rinze" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="nth" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="amn" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="tenka" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="chyk" onmouseover="xuanzhong()"></div>

</div>

</th>

</tr>

</table>

<table>

<tr>

<th colspan="3" style="height: 100px;"><img src="zh/sl.png" alt="" class="zh"></th>

<th colspan="4" style="height: 100px;"><img src="zh/noc.png" alt="" class="zh"></th>

</tr>

<tr>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="ash" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="fyk" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mei" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="toru" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mdk" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="koito" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="hnn" onmouseover="xuanzhong()"></div>

</div>

</th>

  

</tr>

</table>

<table>

<tr>

<th colspan="2"><img src="zh/ss.png" alt="" class="zh" style="height: 60px;"></th>

<th colspan="3"><img src="zh/co.png" alt="" class="zh"></th>

</tr>

<tr>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="nck" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mkd" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="luka" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="hana" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="hrk" onmouseover="xuanzhong()"></div>

</div>

</th>

</tr>

</table>

</div>

</div>

  

</body>

  

</html>
```
* **
* ## css文档
### style.css
这里有做一个鼠标移动上去图片逐渐变换的效果，但html文档暂时还没用到。具体效果可见<https://mzh.moegirl.org.cn/%E5%81%B6%E5%83%8F%E5%A4%A7%E5%B8%88_%E9%97%AA%E8%80%80%E8%89%B2%E5%BD%A9>里“登场角色”栏中的效果
```
.hbg{

background-color: yellow;

}

.hl{

color: red;

}

.ho{

transition: color 1.2s ease-in-out;

}

.ho:hover{

color: #8adfff;

clear: both;

}

.ho{

position: relative; /* 为伪元素定位提供基础 */

cursor: pointer; /* 鼠标指针样式 */

}

  

.ho:hover::after {

content: '象征青空的企划色: . .#8adfff'; /* 显示的文字内容 */

position: absolute;

font-style: normal;

top: 60px; /* 调整伪元素垂直位置 */

right: 110px; /* 调整伪元素水平位置 */

color: black; /* 文字颜色 */

font-size: 12px; /* 字体大小 */

white-space: nowrap; /* 防止文字换行 */

}

  

.ho:hover::before {

content:'';

position: absolute;

top: 63px;

right: 155px;

width: 10px;

height: 10px;

background-color: #8adfff; /* 方块颜色 */

border: 1px solid #ccc; /* 可选边框 */

border-radius: 2px;

z-index: 10;

}

#bian{

height: 350px;

display: inline-block;

}

.idolphoto2,.idolphoto1{

width:200px ;

border: 10px solid silver ;

}

#bian:hover>.idolphoto1{

opacity: 1;

box-shadow: 5px 5px 10px rgb(0,0,0,0.5);

}

#bian:hover>.idolphoto2{

opacity: 0;

}

#bian>.idolphoto2,.idolphoto1{

transition: opacity 0.8s;

opacity: 1;

position: absolute;

top:850px;

}

#bian>.idolphoto1{

opacity: 0;

}

.bjtp {

position: fixed;

top: 0;

left: 0;

background-image: url("1.png");

background-size: cover;

height: 100%;

width: 100%;

}

  

.photo {

position: fixed;

left: 0px;

top: 0px;

z-index: -1;

user-select: none;

}

  

#topicbox {

display: flex;

height: 150px;

width: 1255px;

background-color: rgb(255, 255, 255);

z-index: 0;

filter: blur(30px);

top: 50px;

position: absolute;

}

  

#topic {

font-size: 50px;

color: black;

font-family: cursive;

position: absolute;

z-index: 1;

display: block;

user-select: none;

}

  

#background {

position: relative;

top: 200px;

margin-left: auto;

margin-right: auto;

width: 1000px;

z-index: 0;

background: rgba(236, 235, 233, 0.9);

padding-bottom: 100px;

}

  

#tphoto {

position: absolute;

width: 200px;

z-index: 2;

left: 553px;

top: 0px;

user-select: none;

}

  

#background .box1 {

height: 150px;

background: rgba(236, 235, 233, 0);

border-left: 10px solid rgb(0, 179, 255);

z-index: 1;

border-radius: 10px;

position: relative;

overflow: hidden;

margin-left: auto;

margin-right: auto;

top: 30px;

}

  

#background .box1 #bz {

float: left;

width: 120px;

margin-top: 10px;

clear: both;

}

  

#background .box1 #biaoyu {

display: block;

font-size: 50px;

font-style: italic;

text-align: center;

margin: 0px;

}

  

#background .box1 #biaoyucn {

display: block;

font-size: 50px;

font-style: italic;

font-family: "KaiTi";

text-align: center;

margin-top: 15px;

margin-bottom: 0px;

}

  

#background .jianjie {

background: rgba(255, 255, 255, 0.5);

width: 800px;

margin-left: auto;

margin-right: auto;

margin-top: 50px;

}

  

#background .box2 {

background: rgba(255, 255, 255, 0.5);

width: 800px;

height: 100px;

margin-left: auto;

margin-right: auto;

}

  

#box0 {

width: 1000px;

z-index: 2;

margin-left: 220px;

margin-top: 95px;

position: absolute;

}

  

.checkboxs {

display: inline;

flex-wrap: wrap;

align-items: center;

justify-content: flex-start;

flex: 1 1 auto;

}

  

.checkbox-container {

width: 100px;

color: #fff;

height: 100px;

min-width: 40px;

padding: 0 8px;

display: inline-flex;

flex: 0 0 auto;

align-items: center;

justify-content: center;

vertical-align: middle;

box-shadow: 0 3px 5px gray;

letter-spacing: .08em;

text-indent: .08em;

cursor: pointer;

}

  

.xz {

box-shadow:0 3px 10px black ;

}

  

table th {

border: 1px solid black;

}

  

.colors {

margin-top: 50px;

margin-right: auto;

margin-left: auto;

border-collapse: collapse;

}

  

table {

margin-right: auto;

margin-left: auto;

border-collapse: collapse;

table-layout:auto;

}

  

.xz1{

box-shadow:5px 8px 20px black ;

}

.qk{

border-radius: 5px;

background-color: #8adfff;

color: white;

position: absolute;

right:30px;

margin-top: 20px;

}

.jieshao{

margin-top: 80px;

width: 600px;

margin-left: auto;

margin-right: auto;

background-color: rgba(255, 255, 255, 0.5);

border-radius: 5px;

align-items: center;

justify-content: center;

border-left: 8px solid red;

font-size: 20px;

}

.zh{

height: 80px;

}

th{

height: 100px;

}
```
<br>

### colors
就是设置背景颜色的
```
#mano{

background-color: #FFBAD6;

}

#jiaozi{

background-color: #144384;

}

#mgr{

background-color: #FFE012;

}

#kgn{

background-color: #F84CAD;

}

#mmm{

background-color: #A846FB;

}

#sky{

background-color: #006047;

}

#fff{

background-color: #3B91C4;

}

#krk{

background-color: #D9F2FF;

}

#kaho{

background-color: #E5461C;

}

#cyk{

background-color: #F93B90;

}

#juri{

background-color: #FFC602;

}

#rinze{

background-color: #89C3EB;

}

#nth{

background-color: #90E667;

}

#amn{

background-color: #F54275;

}

#tenka{

background-color: #E75BEC;

}#chyk{

background-color: #FBFAFA;

}

#ash{

background-color: #F30100;

}

#fyk{

background-color: #5CE626;

}

#mei{

background-color: #FF00FF;

}

#toru{

background-color: #50D0D0;

}

#mdk{

background-color: #BE1E3E;

}

#koito{

background-color: #7967C3;

}

#hnn{

background-color: #FFC639;

}

#nck{

background-color: #A6CEB6;

}

#mkd{

background-color: #760F10;

}

#luka{

background-color: #24130D;

}

#hana{

background-color: #E0B5D3;

}

#hrk{

background-color: #EAD7A4;

}
```
<br>

## JavaScript文档
目前没怎么学，不太会用
### 1.js
```
var currentDate = new Date();

var Hour = currentDate.getHours();

console.log(Hour);

if(Hour>=6&&Hour<=12){

alert("早上好~制作人");

}else if(Hour>12&&Hour<=17){

alert("下午的工作也要加油哦，制作人");

}else if(Hour>17&&Hour<=23){

alert("晚上要不要去看星星呢~");

}else{alert("这么晚了还不睡觉，Mr.作息失调");}

  
  
  
  
  

function xuanzhong(){

document.querySelectorAll('.checkbox-container').forEach(function(box) {

box.addEventListener("click", function() {

document.querySelectorAll('.checkbox-container.xz1').forEach(function(selectedBox) {

selectedBox.classList.remove('xz1');

});

box.classList.add('xz1');

});

document.querySelectorAll('.checkbox-container').forEach(function(box) {

box.addEventListener("mouseover", function() {

document.querySelectorAll('.checkbox-container.xz').forEach(function(selectedBox) {

selectedBox.classList.remove('xz');

});

box.classList.add('xz');

});

box.addEventListener("mouseleave", function() {

document.querySelectorAll('.xz').forEach(function(selectedBox) {

selectedBox.classList.remove('xz');

});

});

}

)})}

  

function qingkong(){

var box=document.querySelector('.qk');

box.addEventListener("mousedown",function(){

document.querySelector('.qk').style.color="black";

document.querySelectorAll('.xz1').forEach(function(selectedBox) {

selectedBox.classList.remove('xz1');

});

})

box.addEventListener("mouseup",function(){

document.querySelector('.qk').style.color="white";

})

}
```
* **
## 图片部分
1.png
![1.png](https://www.project-imas.wiki/images/7/76/SC_S_Higuchi_Madoka_SR04.jpg)
<br>
2.png
![输入图片说明](https://www.project-imas.wiki/images/3/3a/THE_iDOLM@STER_Shiny_Colors_2023_Logo.png)
<br>
283.png
![输入图片说明](https://www.project-imas.wiki/images/2/22/283Pro_Logo.png)
<br>
283pro.png
![输入图片说明](https://www.project-imas.wiki/images/7/71/283.jpg)
<br>
* **
### zh文件夹
xing.png
![输入图片说明](https://www.project-imas.wiki/images/thumb/8/80/Illumination_STARS_logo.png/800px-Illumination_STARS_logo.png)
<br>
ant.png
![输入图片说明](https://www.project-imas.wiki/images/thumb/9/99/L%27Antica_logo.png/800px-L%27Antica_logo.png)
<br>
hua.png
![输入图片说明](https://www.project-imas.wiki/images/9/9d/Logo_ALSTROEMERIA.png)
<br>
fkh.png
![输入图片说明](https://www.project-imas.wiki/images/thumb/f/f0/Houkago_Climax_Girls_Logo.png/800px-Houkago_Climax_Girls_Logo.png)
<br>
sl.png
![输入图片说明](https://www.project-imas.wiki/images/2/23/STRAYLIGHT.png)
<br>
noc.png
![输入图片说明](https://www.project-imas.wiki/images/5/5b/Noctchill_unit_logo.png)
<br>
ss.png
![输入图片说明](https://www.project-imas.wiki/images/a/a3/SHHis_Unit_logo.png)
<br>
co.png
![输入图片说明](https://www.project-imas.wiki/images/6/6e/CoMETIK_Unit_logo.png)
